package pandigitalPrime;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class Problem41 {
    /**
     * Method to determine if a given number is a prime number
     *
     * @param n
     */
    private static boolean isPrime(long n) {
        if (n == 2) { return true; }
        if (n < 2 || n % 2 == 0) { return false; }
        for (int i = 3; i * i <= n; i += 2) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }

    /**
     * This method uses BigInteger api to determine if a given number is a prime number
     *
     * @param n
     */
    private static boolean isPrime(BigInteger n) {
        return n.isProbablePrime(10);
    }

    /**
     * This method arranges all digits in the array as a single integer, in the exact order as present in the array
     *
     * @param digits
     */
    private static BigInteger getNumber(int[] digits) {
        StringBuilder sb = new StringBuilder();
        for (int digit : digits) {
            sb.append(digit);
        }
        return new BigInteger(sb.toString());
    }

    /**
     * This method is used to return a list of all integers containing n-digits. Algo :
     * 1. Get all the digits from 1 to n, in the form of an array
     * 2. Get all the permutations for the given array. Each order of array then signify a unique number
     * 3. Add these numbers in the result list
     * 4. Return the list
     *
     * @param n
     */
    private static List<BigInteger> getPandigitalNumbers(int n) {
        int[] digits = getDigits(n);
        List<BigInteger> numbersList = new ArrayList<>();

        for (int[] digitArray : permutation(digits)) {
            numbersList.add(getNumber(digitArray));
        }
        return numbersList;
    }

    /**
     * This method is used to get all the permutations for a given array of integers
     *
     * @param digits
     */
    private static List<int[]> permutation(int[] digits) {
        List<int[]> digitsArray = new ArrayList<>();

        if (digits.length == 1) {
            digitsArray.add(digits);
        } else {
            int lastDigit = digits[digits.length - 1];
            int[] leftArray = getRemainingArray(digits);

            digitsArray = merge(permutation(leftArray), lastDigit);
        }
        return digitsArray;
    }

    /**
     * This method returns the array that which is left after removing the integer at the last index
     *
     * @param digits
     */
    private static int[] getRemainingArray(int[] digits) {
        int[] remArray = new int[digits.length - 1];
        for (int i = 0; i < digits.length - 1; i++) {
            remArray[i] = digits[i];
        }
        return remArray;
    }

    /**
     * This method merges the given integer n, at all possible positions in the arrays. Gives the permutations
     * possible for a given set of arrays
     *
     * @param digitsArray
     * @param n
     */
    private static List<int[]> merge(List<int[]> digitsArray, int n) {
        List<int[]> result = new ArrayList<>();

        for (int[] digitArray : digitsArray) {
            for (int i = 0; i <= digitArray.length; i++) {
                int[] permutedArray = getPermutedArray(digitArray, n, i);
                result.add(permutedArray);
            }
        }
        return result;
    }

    /**
     * Returns a new array with the position of integer n, at the given position i in the array
     *
     * @param digitsArray
     * @param n
     * @param i
     */
    private static int[] getPermutedArray(int[] digitsArray, int n, int i) {
        int[] permutedArray = new int[digitsArray.length + 1];
        for (int a = 0; a < digitsArray.length; a++) {
            permutedArray[a] = digitsArray[a];
        }
        permutedArray[i] = n;
        for (int j = i; j < digitsArray.length; j++) {
            permutedArray[j + 1] = digitsArray[j];
        }
        return permutedArray;
    }

    /**
     * This method is used to get all the digits from 1 to n, in the form of an array
     *
     * @param n
     */
    private static int[] getDigits(int n) {
        int[] digits = new int[n];
        for (int i = 1; i <= n; i++) {
            digits[i - 1] = i;
        }
        return digits;
    }

    /**
     * Checks if the number is panDigital - it means each digit from 1 to n in a n-digit number occurs only once
     * <p>
     * Inherently limited to check upto 9-digit numbers
     * </p>
     *
     * @param n
     */
    private static boolean isPandigital(long n) {
        String num = String.valueOf(n);
        if (num.length() > 9) { return false; }
        Set<Character> set = new HashSet<>();
        for (char c : num.toCharArray()) {
            if (set.contains(c)) {
                return false;
            } else {
                set.add(c);
            }
        }
        return true;
    }

    /**
     * Main method to get the largest panDigital prime number. Algo:
     * 1. For a given integer n, get all the digits from 1 to n in the form of an array such that they occur only once
     * 2. Do permutations of that array to arrange the digits in all possible orders. Since each digit from 1 to n
     * occurs only once in the array, hence each permutation is in itself a panDigital number
     * 3. Get all such permutations where each order is a number and store them in a list
     * 4. Check if any of the numbers is also a prime number, and get the max out of them
     * <p>
     * The algorithm is highly inefficient -- O(n * n!) where n is the number of digits
     * </p>
     * <p>
     * Accepted answer is a 7-digit panDigital number == 7652413
     * Largest n-digit panDigital prime number found was a 10-digit number == 98765421103
     * <p>
     * Beyond n = 11, it throws an OutOfMemory error
     * </p>
     *
     * @param args
     */
    public static void main(String[] args) {
        long startTime = System.currentTimeMillis();

        BigInteger result = BigInteger.ZERO;
        for (int n = 2; n < 11; n++) {
            List<BigInteger> numbersList = getPandigitalNumbers(n);
            for (BigInteger b : numbersList) {
                if (isPrime(b)) {
                    result = result.max(b);
                }
            }
        }
        long endTime = System.currentTimeMillis();
        System.out.println("Largest n-digit pandigital prime is - " + result.toString());
        System.out.println("Total time taken - " + (endTime - startTime));
    }
}
